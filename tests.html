<!DOCTYPE html>
<html>
	<head>
		<title>Multisort UX tests</title>
		<meta charset="utf8" />
		<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.20.0.css">
		<link rel="stylesheet" media="all" type="text/css" href="css/multisort-ux-2.css" />
		<script src="http://code.jquery.com/qunit/qunit-1.20.0.js"></script>
		<script src="js/multisort-ux-2.js" type="text/javascript"></script>
		<script src="js/array-unique.js" type="text/javascript"></script>
		<script type="text/javascript">
		
		function getMatrix(r, c) {	
			var i = 0, l, b, m = [], p, w = 0, log = 1;
			
			b = Array.apply(null, Array(c)).map(Number.prototype.valueOf,0);
			l = r;
			p = Math.round(l / c);
				
			if (log) console.log('data matrics for (', b.length, ') column table');
			
			for (; i < l; i += 1) {
				if (i % p) {
					w +=1;
					if (w === b.length) {
						w = 0;
					}
					b[w] -= 1;
				} else {
					b[w] += 1;
				}
				b[w] = Math.abs(b[w]);
				if (log) console.log(b);
				m.push(b.slice(0));
			}
			
			return m;
		}
		
		function formatData(d) {
			var data = [],
			a = getLetters(), 
			c,
			i = 0, 
			l = d.length, 
			o,
			r,
			t;
			
			for (; i < l; i += 1) {
				o = {};
				o.id = i + 1;
				r = d[i]; 
				if (!c) c = r.length;
				for(t = 0; t < c; t += 1) {
					o[a[t]] = r[t];
				}
				data.push(o);
			}
			return data;
		}
		
		function FindAllLetterCasePermutations(s) {
			var sp = s.split(""), buffer = [];
			for (var i = 0, l = 1 << s.length; i < l; i++) {
				for (var j = i, k = 0; j; j >>= 1, k++) {
					sp[k] = (j & 1) ? sp[k].toUpperCase() : sp[k].toLowerCase();
				}
				buffer.push(sp.join(""));
			}
			return buffer;
		}
		
		function FindAllPermutations(str, index, buffer) {
			if (typeof str == "string")
				str = str.split("");
			if (typeof index == "undefined")
				index = 0;
			if (typeof buffer == "undefined")
				buffer = [];
			if (index >= str.length)
				return buffer;
			for (var i = index; i < str.length; i++)
				buffer.push(ToggleLetters(str, index, i));
			return FindAllPermutations(str, index + 1, buffer);
		}

		function ToggleLetters(str, index1, index2) {
			if (index1 != index2) {
				var temp = str[index1];
				str[index1] = str[index2];
				str[index2] = temp;
			}
			return str.join("");
		}
		
		function getPattern(l) {
			var c, buffer = [], pattern = {};
			c = FindAllPermutations(getLetters().splice(0, l).join(''));
			for (var i = 0, l = c.length; i < l; i += 1) {
				buffer = buffer.concat(FindAllLetterCasePermutations(c[i]));
			}
			buffer = buffer.getUnique();
			
			(function () {
				for (var i = 0, l = buffer.length; i < l; i += 1) {
					console.log('test case:', buffer[i]);
				}
			})();
			
			buffer.map(function (s) {
				var r = s.split('');
				pattern[s] = [];
				for (var i = 0, l = r.length; i < l; i += 1) {
					pattern[s].push([r[i].toLowerCase(), r[i] === r[i].toLowerCase() ? '<' : '>']);
				}
			});
			pattern.expected = buffer.length;
			return pattern;
		}

		QUnit.test('reindexing array shifting index 3 to index 2', function(assert) {
			var testArray = [], a, b, p, x;
			
			assert.notOk(testArray.length, 'empty array');
			for (var i = 0; i < 10; i += 1) {
				testArray[i] = [i.toString(10)];
			}
			assert.equal(testArray.length, 10, 'array length is correct');
			assert.notOk(testArray[testArray.length], 'index out of reach');
			assert.equal(testArray[testArray.length - 1], testArray[9], 'elements are indexed correct');
			
			a = testArray[3];
			b = testArray[2];
			p = 3;
			
			assert.equal(testArray[3], a, 'arrays in arrays are stored by referrence');
			
			// shifting up
			x = testArray[p - 1];
			testArray[p - 1] = testArray[p];
			testArray[p] = x;
			
			assert.equal(testArray.length, 10, 'length of the array is unchanged');
			assert.equal(testArray[2], a, 'referenced array ( a ) can be found on lower index');
			assert.equal(testArray[3], b, 'referenced array ( b ) can be found on higher index');
		});
		
		QUnit.test('reindexing array pushing index 3 to index 4', function(assert) {
			var testArray = [], a, b, p, x;
			for (var i = 0; i < 10; i += 1) {
				testArray[i] = [i.toString(10), '+'];
			}
			
			a = testArray[3];
			b = testArray[4];
			p = 3;
			
			// pushing down
			x = testArray[p];
			testArray[p] = testArray[p + 1];
			testArray[p + 1] = x;
			
			assert.equal(testArray.length, 10, 'length of the array is unchanged');
			assert.equal(testArray[3], b, 'referenced array ( b ) can be found on lower index');
			assert.equal(testArray[4], a, 'referenced array ( a ) can be found on higher index');
		});
		
		function compareResults(assert, expected, tests) {
			var last = '', cnt = 0;
			for (var r in tests.individualResults) {
				(function (current) {
					if (!last)  {
						last = current;
					} else {
						if (tests.individualResults[last].join('') == tests.individualResults[current].join('')) {
							console.log(last, tests.individualResults[last].join(''));
							console.log(current, tests.individualResults[current].join(''));
							last = '';
						}
					}
				})(r);
				cnt++;
			}
			
			assert.ok(last, 'no duplicate results found in individual tests');
			
			var unique = tests.totalResults.map(function (i) {
				return i.join('');
			});
			
			assert.equal(unique.length, expected, 'all tests passed');
			assert.equal(unique.getUnique().length, expected, 'result length unchanged after filtering duplicates');
		}
		
		
		QUnit.test('multi sorting: running tests on two column table', function (assert) {
			var pattern = getPattern(2), data = formatData(getMatrix(pattern.expected, 2)), tests = {};
			tests.individualResults = {};
			tests.totalResults = [];
			
			function storeResults(test, result) {
				tests.individualResults[test] = result.map(function (o) {
					return o.id;
				});
				tests.totalResults.push(tests.individualResults[test]);
			};
			
			for (var test in pattern) {
				if (test === "expected") continue;
				(function (test) {
					storeResults(test, data.slice(0).sort(sortByMultiple.apply(null, pattern[test])));
				})(test);
			}
			
			compareResults(assert, pattern.expected, tests);
			
		});
		
		QUnit.test('multi sorting: running tests on three column table', function (assert) {

			var pattern = getPattern(3), data = formatData(getMatrix(pattern.expected, 3)), tests = {};
			tests.individualResults = {};
			tests.totalResults = [];
			
			function storeResults(test, result) {
				tests.individualResults[test] = result.map(function (o) {
					return o.id;
				});
				tests.totalResults.push(tests.individualResults[test]);
			};
			
			for (var test in pattern) {
				if (test === "expected") continue;
				(function (t) {
					if (['individualResults', 'totalResults'].indexOf(t) < 0) {
						storeResults(test, data.slice(0).sort(sortByMultiple.apply(null, pattern[t])));
					}
				})(test);
			}
			
			compareResults(assert, pattern.expected, tests);
		});
		
		QUnit.test('multi sorting: running tests on four column table', function (assert) {

			var pattern = getPattern(4), data = formatData(getMatrix(pattern.expected, 4)), tests = {};
			tests.individualResults = {};
			tests.totalResults = [];
			
			function storeResults(test, result) {
				tests.individualResults[test] = result.map(function (o) {
					return o.id;
				});
				tests.totalResults.push(tests.individualResults[test]);
			};
			
			for (var test in pattern) {
				if (test === "expected") continue;
				(function (t) {
					if (['individualResults', 'totalResults'].indexOf(t) < 0) {
						storeResults(test, data.slice(0).sort(sortByMultiple.apply(null, pattern[t])));
					}
				})(test);
			}
			
			compareResults(assert, pattern.expected, tests);
		});
		
		QUnit.test('multi sorting: running tests on five column table', function (assert) {

			var pattern = getPattern(5), data = formatData(getMatrix(pattern.expected, 5)), tests = {};
			tests.individualResults = {};
			tests.totalResults = [];
			
			function storeResults(test, result) {
				tests.individualResults[test] = result.map(function (o) {
					return o.id;
				});
				tests.totalResults.push(tests.individualResults[test]);
			};
			
			for (var test in pattern) {
				if (test === "expected") continue;
				(function (t) {
					if (['individualResults', 'totalResults'].indexOf(t) < 0) {
						storeResults(test, data.slice(0).sort(sortByMultiple.apply(null, pattern[t])));
					}
				})(test);
			}
			
			compareResults(assert, pattern.expected, tests);
		});
		
		QUnit.test('testing checkboxes and event handlers', function(assert) {
			
			var sortPattern = [], pattern = getPattern(2), data = formatData(getMatrix(pattern.expected, 2));
			
			var done = assert.async();
			
			document.querySelector('#my-table').addEventListener('selection', function (e) {
				assert.ok(e.detail, 'custom event supported');
				done();
			});
			
			for (var test in pattern) {
				if (test === "expected") continue;
				(function (t) {
					sortPattern.push(pattern[test]);
				})(test);
			}
			renderTable({
				'data' : data,
				'sortPattern' : sortPattern
			});
			
			var onbtns = document.querySelectorAll('.on b');
			assert.equal(onbtns.length, 2, 'table is rendered and we have buttons');
			onbtns[0].dispatchEvent(new MouseEvent('click'));
		});
		
		</script>
	</head>
	<body>
		
		<div id="qunit"></div>

		<div id="qunit-fixture">
			<table id="my-table" class="basic">
				<caption>
					<textarea>
						<tr>
							<td><input type="checkbox" {{checked}} value="{{id}}" /></td>
							<td>{{a}}</td>
							<td>{{b}}</td>
						</tr>
					</textarea>
					
					<div class="counters">
						<span class="selected">0</span>/<span class="total">0</span>
					</div>
					
					<div class="select-limit-controls">
						<label>Limit</label>
						<input value="" size="5" />
						<span class="increment"></span>
						<span class="decrement"></span>
					</div>
					
				</caption>
				<thead>
					<tr>
						<td><input type="checkbox" checked /></td>
						<td data-col="a">A</td>
						<td data-col="b">B</td>
					</tr>
				<thead>
				<tfoot></tfoot>
				<tbody></tbody>
			</table>
		</div>
	</body>
</html>